# Inicializa√ß√£o do projeto

O primeiro passo √© criar uma simples p√°gina HTML que exiba o formul√°rio e uma lista de mensagens. 

Usaremos o framework web Node.JS express para isso. Certifique-se que o *Node.JS* est√° instalado.

## Criando o package.json

Primeiro, vamos criar um package.json que descreve nosso projeto:

```json
{
  "name": "socket-chat",
  "version": "0.0.1",
  "description": "my first socket.io app",
  "type": "module",
  "dependencies": {}
}
```
üí° Recomenda-se colocar em um diret√≥rio vazio dedicado (socket-chat)

‚ö†Ô∏è Aten√ß√£o: A propriedade "name" deve ser √∫nica. Voc√™ n√£o pode usar um valor como "socket.io" ou "express", porque o npm reclamar√° ao instalar a depend√™ncia.

## Depois de instalado, podemos criar um index.js que configurar√° nosso aplicativo
```
import express from 'express';
import { createServer } from 'node:http';

const app = express()
const server = createServer(app);

app.get('/', (req), res)=>{
	res.send('<h1>Hellow World!</h1>');
	});

server.listen(3000, ()=>{
	console.log('server runing at http://localhost:3000');
	});
```
Isso significa que o Express √© iniciado para ser um manipulador de fun√ß√µes que voc√™ pode fornecer a um servidor HTTP

Definimos um manipulador de rotas ‚Äò/‚Äô que √© chamado quando acessamos a p√°gina inicial do nosso projeto

Fizemos o servidor http rodar na porta 3000

Se executar o node index,js dever√° aparecer o seguinte:
![alt text]({9B24DF34-EA6E-4190-9002-40AC67847DCB}.png)

E se acessar http://localhost:3000: no navegador teremos :

![alt text]({57AA3B78-534B-49A8-818F-642B059738AE}.png)

## Gerenciando depend√™ncias e arquivos ignorados

Ao executar npm install, o NPM cria a pasta node_modules com todas as depend√™ncias. Por boas pr√°ticas:

### O que voc√™ deve fazer:

**Crie um arquivo `.gitignore`** na raiz do projeto com:
   ```gitignore
  # Depend√™ncias
node_modules/

# Ambiente
.env
.env.local

# Logs e tempor√°rios
*.log
npm-debug.log*
.DS_Store

# IDEs/Editores
.idea/
.vscode/
*.swp

# Sistema operacional
Thumbs.db
```
## Servindo o HTML

At√© agora, no index.js estamos chamando res.send e passando uma string HTML. Nosso c√≥digo ficar√° muito confuso se simplesmente coloc√°ssemos o HTML inteiro do aplicativo ali, ent√£o, vamos criar um index.html e servi-lo

Vamos refatorar nosso manipulador de rotas para usar sendFile em vez disso

```jsx
import express from 'express';
import { createServer } from 'node:http';
import { fileURLToPath } from 'node:url';
import { dirname, join } from 'node:path';

const app = express();
const server = createServer(app);

const __dirname = dirname(fileURLToPath(import.meta.url));

app.get('/', (req, res) => {
  res.sendFile(join(__dirname, '/templates/index.html'));
});

server.listen(3000, () => {
  console.log('server running at http://localhost:3000');
});
```

Agora, devemos criar dois diret√≥rios na raiz do nosso projeto static e template

- Dentro do diret√≥rio static, criaremos outros dois diret√≥rios
    - js - para guardarmos arquivos .js
    - css - para guardarmos arquivos css
    
    Cada arquivo deve conter o nome de refer√™ncia do html, como estamos trabalhando no index, nossos arquivos agora ter√£o o prefixo index
    
- Dentro do diret√≥rio templates, guardaremos os arquivos html da nossa aplica√ß√£o

Vamos criar nosso arquivo index.html dentro do diret√≥rio templates, e nele teremos o seguinte esqueleto do site:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socket.IO chat</title>
    <link rel="stylesheet" href="/static/css/index.css"> <!--link para o css-->
</head>
<body>
    <ul id="messages"></ul>
    <form id="form" action="">
        <input id="input" autocomplete="off" /><button>Send</button>
    </form>
</body>
</html>
```

Dentro do nosso diret√≥rio Css, localizado em static, vamos criar o arquivo index.css:
```css
body {
    margin: 0;
    padding-bottom: 3rem;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

#form {
    background: rgba(0, 0, 0, 0.15);
    padding: 0.25rem;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    height: 3rem;
    box-sizing: border-box;
    backdrop-filter: blur(10px);
}

#input {
    border: none;
    padding: 0 1rem;
    flex-grow: 1;
    border-radius: 2rem;
    margin: 0.25rem;
}

#input:focus {
    outline: none;
}

#form>button {
    background: #333;
    border: none;
    padding: 0 1rem;
    margin: 0.25rem;
    border-radius: 3px;
    outline: none;
    color: #fff;
}

#messages {
    list-style-type: none;
    margin: 0;
    padding: 0;
}

#messages>li {
    padding: 0.5rem 1rem;
}

#messages>li:nth-child(odd) {
    background: #efefef;
}

```
Ao rodar novamente o projeto atrav√©s do index.js, teremos a p√°gina atualizada, apresentando um campo de input e um bot√£o. Caso sua aplica√ß√£o n√£o esteja da mesma forma, favor revisar o c√≥digo

## Integrando o Socket.IO

O [socket.io](http://socket.io) √© composto de duas partes :

- Um servidor que se integra com servidor HTTP Node.JS
- Uma biblioteca cliente que carrega no lado do navegador

Vamos instalar um m√≥dulo apenas por enquanto

```css
npm install socket.io
```

Isso instalar√° o m√≥dulo e adicionar√° a depend√™ncia ao package.json. Agora vamos editar o index.js para adiciona-lo

```jsx
import express from 'express';
import { createServer } from 'node:http';
import { fileURLToPath } from 'node:url';
import { dirname,join } from 'node:path';
import { Server } from 'socket.io'; //new

const app = express();
const server = createServer(app);
const io = new Server(server); //new

const __dirname = dirname(fileURLToPath(import.meta.url));

app.get('/', (req, res) => {
  res.sendFile(join(__dirname, '/templates/index.html'));
});

io.on('connection', (socket) => { //new
    console.log('a user connected');
});

server.listen(3000, () => {
  console.log('server running at http://localhost:3000');
});
```

Observe que uma nova int√¢ncia de [socket.io](http://socket.io) passando o server. Em seguida, executo o evento connection em busca de sockets de entrada e registro no console

Agora em index.html adicione o seguinte snippet antes do body

```html
<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();
</script>
```

Observe que n√£o estou especificando nenhuma URl quando chamo io(), pois o padr√£o √© tentar se conectar ao host que serve a p√°gina

Agora, ao executar novamente o index.js, ‚Äúa user connected‚Äù ser√° exibida no terminal 

Cada soquete tamb√©m dispara um¬†`disconnect`evento especial:

```jsx
import express from 'express';
import { createServer } from 'node:http';
import { fileURLToPath } from 'node:url';
import { dirname,join } from 'node:path';
import { Server } from 'socket.io';

const app = express();
const server = createServer(app);
const io = new Server(server);

const __dirname = dirname(fileURLToPath(import.meta.url));

app.get('/', (req, res) => {
  res.sendFile(join(__dirname, '/templates/index.html'));
});

io.on('connection', (socket) => {
    console.log('a user connected');
    socket.on('disconnect', () => {
      console.log('user disconnected');
    });

});

server.listen(3000, () => {
  console.log('server running at http://localhost:3000');
});
```

Ao atualizar a p√°gina v√°rias vezes, podemos ver que no output, a mensagem de usu√°rio desconectado ser√° exibida, ap√≥s isso, ser√° conectado novamente

## ‚ôªÔ∏è **Reestrutura√ß√£o de Arquivos para Boas Pr√°ticas**

Para atender boas pr√°ticas de organiza√ß√£o e clareza no projeto, foram realizadas as seguintes altera√ß√µes:

- O arquivo originalmente chamado `index.js` (localizado na raiz do projeto) foi renomeado para `main.js`. Essa mudan√ßa visa deixar claro que se trata do arquivo principal de execu√ß√£o do servidor.

- Foi criado um novo arquivo `index.js`, agora localizado em um diret√≥rio apropriado (como `static/js/`), exclusivamente para a l√≥gica da p√°gina `index.html`.

- Os scripts que estavam embutidos no `index.html` foram removidos e movidos para esse novo `index.js`, centralizando e organizando melhor o c√≥digo JavaScript da interface.

Essas mudan√ßas tornam a estrutura do projeto mais compreens√≠vel e alinhada com boas pr√°ticas de desenvolvimento web.

## ## Emitindo eventos

A ideia principal por tr√°s do [socket.io](http://socket.io) √© que voc√™ pode enviar e receber quaisquer eventos que desejar, com quaisquer dados que desejar. Qualquer objeto que possa ser codificado como JSON serve, e dados bin√°rios tamb√©m s√£o suportados.

Vamos fazer com que, quando o usu√°rio digitar uma mensagem, o servidor receba como um evento  chat message. 

Nosso index.js agora ficar√° assim:

```jsx
const socket = io();

const form = document.getElementById('form');
const input = document.getElementById('input');

form.addEventListener('submit', (e) => {
  e.preventDefault();
  if (input.value) {
    socket.emit('chat message', input.value);
    input.value = '';
  }
});
```

Nosso main.js ficara assim:

``` 
import express from 'express';
import { createServer } from 'node:http';
import { fileURLToPath } from 'node:url';
import { dirname,join } from 'node:path';
import { Server } from 'socket.io';

const app = express();
const server = createServer(app);
const io = new Server(server);

const __dirname = dirname(fileURLToPath(import.meta.url));

// Configura√ß√£o CORRETA para arquivos est√°ticos
app.use('/static', express.static(join(__dirname, 'static'))); // Serve /static/css e /static/js

app.get('/', (req, res) => {
  res.sendFile(join(__dirname, '/templates/index.html'));
});

io.on('connection', (socket) => {
  console.log('a user connected');
  
  socket.on('disconnect', () => {
    console.log('user disconnected');
    });

  socket.on('chat message', (msg) => {
    console.log('message: ' + msg);
    io.emit('chat message', msg);  
});

});

server.listen(3000, () => {
  console.log('server running at http://localhost:3000');
});
```
*_Outras altera√ß√µes e corre√ß√µes poder√£o ser vistos atrav√©s dos commits do projeto_*

## Transmi√ß√£o
## Transmiss√£o

O pr√≥ximo objetivo √© emitir o evento do servidor para o resto dos usu√°rios

Para enviar um evento para todos, o [Socket.io](http://Socket.io) nos fornece o io.emit()

```jsx
// this will emit the event to all connected sockets
io.emit('hello', 'world');
```

Se voc√™ quiser enviar uma mensagem para todos, exceto para um determinado socket anterior, temos o broadcast  para emiss√£o desse socket

```jsx
io.on('conecton', (socket) => {
	socket.broadcast.emit('hi');
	});
```

Os arquivos ficaram assim :
```jsx
import express from 'express';
import { createServer } from 'node:http';
import { fileURLToPath } from 'node:url';
import { dirname,join } from 'node:path';
import { Server } from 'socket.io';

const app = express();
const server = createServer(app);
const io = new Server(server);

const __dirname = dirname(fileURLToPath(import.meta.url));

// Configura√ß√£o CORRETA para arquivos est√°ticos
app.use('/static', express.static(join(__dirname, 'static'))); // Serve /static/css e /static/js

app.get('/', (req, res) => {
  res.sendFile(join(__dirname, '/templates/index.html'));
});

io.on('connection', (socket) => {
  console.log('a user connected');

  // Envia mensagem de boas-vindas apenas para o novo usu√°rio
  socket.emit('chat message', 'Welcome to socketio chat!');

  // Envia mensagem para todos os usu√°rios, exceto o novo usu√°rio
  socket.broadcast.emit('chat message', 'A new user has joined the chat');
  
  socket.on('disconnect', () => {
    console.log('user disconnected');
    });

  socket.on('chat message', (msg) => {
    io.emit('chat message', msg);  
});

});

server.listen(3000, () => {
  console.log('server running at http://localhost:3000');
});
```
```jsx
const socket = io();

const form = document.getElementById('form');
const input = document.getElementById('input');
const messages = document.getElementById('messages');

form.addEventListener('submit', (e) => {
  e.preventDefault();
  if (input.value) {
    socket.emit('chat message', input.value);
    input.value = '';
  }
});

socket.on('chat message', (msg) => {
  const item = document.createElement('li');
  item.textContent = msg;
  messages.appendChild(item);
  window.scrollTo(0, document.body.scrollHeight);
}
);
```
*_O style da p√°gina foi alteraado para melhor visualiza√ß√£o_*

## Lidando com desconex√µes

Agora vamos destacar duas propriedades importantes do Socket.io:

1. Um cliente nem sempre est√° conectado
2. Um servidor n√£o armazena nenhum evento

üö®
Mesmo em uma rede est√°vel, n√£o √© poss√≠vel manter uma conex√£o ativa para sempre.
O que significa que a aplica√ß√£o precisa ser capaz de sincronizar o estado local do cliente com o estado global no servidor ap√≥s uma desconex√£o tempor√°ria
O cliente tentar√° se reconectar automaticamente ap√≥s um pequeno atraso. No entanto, qualquer evento perdido durante o per√≠odo de desconex√£o ser√° efetivamente perdido para este cliente

## Recupera√ß√£o do estado de conex√£o
Agora vamos destacar duas propriedades importantes do Socket.io:

1. Um cliente nem sempre est√° conectado
2. Um servidor n√£o armazena nenhum evento

Mesmo em uma rede est√°vel, n√£o √© poss√≠vel manter uma conex√£o ativa para sempre.

O que significa que a aplica√ß√£o precisa ser capaz de sincronizar o estado local do cliente com o estado global no servidor ap√≥s uma desconex√£o tempor√°ria
O cliente tentar√° se reconectar automaticamente ap√≥s um pequeno atraso. No entanto, qualquer evento perdido durante o per√≠odo de desconex√£o ser√° efetivamente perdido para este cliente


## Recupera√ß√£o do estado de conex√£o

Primeiro vamos lidar com desconex√µes fingindo que n√£o houve desconex√£o: esse recurso √© chamado de ‚ÄúRecupera√ß√£o do estado de conex√£o‚Äù

Este recurso  armazenar√° temporariamente todos os eventos enviados pelo servidor e tentar√° restaurar o estado de um cliente quando ele se reconectar:

- Restaurar seus os ‚Äúrooms‚Äù
- Envia quaisquer eventos perdisos

Deve ser habilitado no lado do servidor (main.js):

```jsx
const io = new Server(server, {
  connectionStateRecovery: {}
});
```

Altera√ß√£o no index.html:

```jsx
<form id="form" action="">
  <input id="input" autocomplete="off" /><button>Send</button>
  <button id="toggle-btn">Disconnect</button>
</form>
```

Altera√ß√£o no index.js:

```jsx
const toggleButton = document.getElementById('toggle-btn');

  toggleButton.addEventListener('click', (e) => {
    e.preventDefault();
    if (socket.connected) {
      toggleButton.innerText = 'Connect';
      socket.disconnect();
    } else {
      toggleButton.innerText = 'Disconnect';
      socket.connect();
    }
  });
```

Esse recurso √© muito √∫til, porque ele n√£o √© implementado por padr√£o ?

- Nem sempre funciona, por exemplo, se o servidor travar abruptamente ou for reiniciado, o estado do cliente n√£o pode ser salvo
- Nem sempre √© poss√≠vel habilitar esse recurso ao aumentar a escala

Dito isso, √© realmente um √≥timo recurso, pois voc√™ n√£o precisa sincronizar o estado do cliente ap√≥s uma desconex√£o tempor√°ria (mudar wifi para 4g)